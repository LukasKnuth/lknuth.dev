<!doctype html><html lang=en-us><head><link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/JetBrainsMono/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-Bold.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-BoldItalic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Dangerously Typed | Lukas Knuth // Developer</title><link rel=canonical href=https://lknuth.dev/writings/dangerously_typed/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Dangerously Typed"><meta property="og:description" content="Why you should be careful when extending build-in types in TypeScript"><meta property="og:type" content="article"><meta property="og:url" content="https://lknuth.dev/writings/dangerously_typed/"><meta property="article:section" content="writings"><meta property="article:published_time" content="2017-01-07T16:05:00+01:00"><meta property="article:modified_time" content="2017-01-07T16:05:00+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dangerously Typed"><meta name=twitter:description content="Why you should be careful when extending build-in types in TypeScript"><link rel=stylesheet href=https://lknuth.dev/css/styles.c80037fe069dacf3e7d215521d1844203a2c7d5d6638afbbbd90798790d40182a5712b247ed5969fa7b0440fd20225fee106d6233729d4fc1e4381fd6b36fd14.css integrity="sha512-yAA3/gadrPPn0hVSHRhEIDosfV1mOK+7vZB5h5DUAYKlcSskftWWn6ewRA/SAiX+4QbWIzcp1PweQ4H9azb9FA=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://lknuth.dev/images/favicon.ico></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><header id=header><a href=https://lknuth.dev/><div id=logo style=background-image:url(https://lknuth.dev/images/logo.png)></div><div id=title><h1>Lukas Knuth // Developer</h1></div></a><div id=nav><ul><li class=icon><a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a></li><li><a href=/>Home</a></li><li><a href=/writings>Writings</a></li><li><a href=/about>About</a></li><li><a href=/imprint>Imprint</a></li></ul></div></header><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class=content itemprop=articleBody><p>At work, I&rsquo;m currently building an new Node.js Application. I opted to use Node, because the application is highly parallel and while I could have build it in Java, Node already does all the hard things that come with building multi-threaded Applications.</p><p>For my language of choice, I looked to <a href=https://www.typescriptlang.org/>TypeScript</a>, because it adds some compile-time type-safety to JavaScript. For the most part, TypeScript has been helping me to write clean code that I can trust when the compiler gives it&rsquo;s &ldquo;all clear&rdquo;. But recently, while hunting an unrelated bug, I stumbled upon something dangerous.</p><h2 id=minimal-working-example>Minimal working example</h2><p>Read the following lines of code and tell me, what they print:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#fe8019>class</span> MyError <span style=color:#fe8019>extends</span> <span style=color:#fabd2f>Error</span> {};
</span></span><span style=display:flex><span><span style=color:#fe8019>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>throw</span> <span style=color:#fe8019>new</span> MyError(<span style=color:#b8bb26>&#34;This is a test&#34;</span>);
</span></span><span style=display:flex><span>} <span style=color:#fe8019>catch</span> (e) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> (e <span style=color:#fe8019>instanceof</span> MyError){
</span></span><span style=display:flex><span>        console.log(<span style=color:#b8bb26>&#34;yay!&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#fe8019>else</span> {
</span></span><span style=display:flex><span>        console.log(<span style=color:#b8bb26>&#34;nay!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It must print &ldquo;yay!&rdquo;, right? Surely it does. Let&rsquo;s try it:</p><pre><code>$ tsc --version
Version 2.1.4
$ node --version
v6.9.4

$ tsc test-error1.ts
$ node test-error1.js
nay!
</code></pre><p>Say what now? What is going on here? We created a custom error-class by extending the build-in type <code>Error</code>, which is also the base-class for all build-in errors that are more specific, like <code>URIError</code> or <code>TypeError</code>. Then, we created an instance of our class and threw it using the <code>throw</code>-keyword.</p><p>But why does it not print &ldquo;yay!&rdquo;, as one would expect? When we use the Nodejs debugger to inspect the type of <code>e</code> at runtime, we get this:</p><pre><code>$ node debug test-error1.js
&lt; Debugger listening on [::]:5858
connecting to 127.0.0.1:5858 ... ok
break in test-error1.js:18
 17 catch (e) {
&gt;18     debugger;
 19     if (e instanceof MyError) {

debug&gt; repl
&gt; e instanceof MyError
false
&gt; e instanceof Error
true
</code></pre><p>Okay. So at runtime, <code>e</code> is not an instance of our own <code>MyError</code>-class, but the base-class <code>Error</code>! That doesn&rsquo;t seem right, what is happening here?</p><h2 id=explanation>Explanation</h2><p>As it turns out after some googleing, this is actually a <a href=https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work>documented breaking change with TypeScript 2.1</a>. Here are the relevant parts:</p><blockquote><p>[&mldr;], <strong>subclassing Error, Array, and others may no longer work as expected</strong>. This is due to the fact that constructor functions for Error, Array, and the like use <strong>ECMAScript 6&rsquo;s <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target>new.target</a> to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ECMAScript 5</strong>. Other downlevel compilers generally have the same limitation by default.</p><p>[&mldr;]</p><p>you may find that:</p><ul><li>methods may be <code>undefined</code> on objects returned by constructing these subclasses, [&mldr;]</li><li><strong><code>instanceof</code> will be broken between instances of the subclass and their instances</strong>, so <code>(new FooError()) instanceof FooError</code> will return <code>false</code>.</li></ul></blockquote><p>This matches our observation. How this doesn&rsquo;t generate at least a compiler-warning is beyond me. But how do we fix it?</p><h2 id=workaround>Workaround</h2><p>The proposed fix given in the breaking changes document is to manually set the prototype of every instance, either by using <code>Object.setPrototype()</code> or the objects <code>__proto__</code>-property. This seems very hacky to me and like something you will probably forget in that one class you wrote at Friday at 5 o&rsquo;clock and then you find yourself debugging all Monday morning. Also, this won&rsquo;t work in IE 10 or older, so if you need your code to run in the Browser, you have to do extra work.</p><p>Another option is to just <em>not</em> extend <code>Error</code>. JavaScript (as opposed to Java) is perfectly happy to throw any kind of object (or string, or number) around:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#fe8019>class</span> MyError {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>constructor</span>(<span style=color:#fe8019>readonly</span> message: <span style=color:#fabd2f>string</span>){}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>throw</span> <span style=color:#fe8019>new</span> MyError(<span style=color:#b8bb26>&#34;This is a test&#34;</span>);
</span></span><span style=display:flex><span>} <span style=color:#fe8019>catch</span> (e) {
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> (e <span style=color:#fe8019>instanceof</span> MyError){
</span></span><span style=display:flex><span>        console.log(<span style=color:#b8bb26>&#34;yay!&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#fe8019>else</span> {
</span></span><span style=display:flex><span>        console.log(<span style=color:#b8bb26>&#34;nay!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This does print &ldquo;yay!&rdquo;, as expected. The drawback is, that the <code>MyError</code>-type doesn&rsquo;t have the <code>stack</code>-property that gives you the StackTrace. You can <a href=http://stackoverflow.com/a/635852/717341>build it yourself</a>, but that seems tedious.</p><p>The third option (and the one I went with) is to change the target of the TypeScript compiler to ECMAScript 6, which has classes and inheritance build-in. This way, the code from the original example just works:</p><pre><code>$ tsc --target es6 test-error1.ts
$ node test-error1.js
yay!
</code></pre><p>Since I run the code on Node exclusively, I can use the transpiled ES6 code just fine (as long as I don&rsquo;t use any <a href=http://node.green/>unsupported features</a>). If you want to use this in a browser, you can run it through <a href=https://babeljs.io/>Babel</a> to get compatible JavaScript. However, this adds another step to your build-process.</p><h2 id=conclusion>Conclusion</h2><p>While inheritance in TypeScript works just fine, you have to be careful when extending any of the build-in types. Also, TypeScript doesn&rsquo;t go out of it&rsquo;s way to tell you about the potential danger of doing it anyways, so be vigilant!</p><ul><li><strong>Don&rsquo;t extend build-in types</strong></li><li>If you must, be sure to <strong>manually set the prototype</strong> of every new instance.</li><li>If you don&rsquo;t want to think about any of this, target ECMAScript 6 with TypeScript (and transpile it, if you can&rsquo;t use it directly).</li></ul></div></article><footer id=footer><div class=footer-left>Copyright &copy; 2023 Lukas Knuth</div><div class=footer-right><nav><ul><li><a href=/>Home</a></li><li><a href=/writings>Writings</a></li><li><a href=/about>About</a></li><li><a href=/imprint>Imprint</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script></html>