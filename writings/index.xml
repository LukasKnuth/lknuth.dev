<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Writings on Lukas Knuth // Developer</title><link>https://lknuth.dev/writings/</link><description>Recent content in Writings on Lukas Knuth // Developer</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Lukas Knuth</copyright><lastBuildDate>Wed, 19 Oct 2022 01:21:00 +0200</lastBuildDate><atom:link href="https://lknuth.dev/writings/index.xml" rel="self" type="application/rss+xml"/><item><title>Test</title><link>https://lknuth.dev/writings/test/</link><pubDate>Wed, 19 Oct 2022 01:21:00 +0200</pubDate><guid>https://lknuth.dev/writings/test/</guid><description>Hello This is a test page
IO.puts(&amp;#34;Syntax highlighting is important!&amp;#34;) &amp;#34;Something Else&amp;#34; |&amp;gt; String.copy() |&amp;gt; Something.else(123) Needs more textual content here&amp;hellip;</description></item><item><title>Making GNOME Shell Extensions</title><link>https://lknuth.dev/writings/making_gnome_shell_extensions/</link><pubDate>Sat, 09 Feb 2013 15:57:38 +0100</pubDate><guid>https://lknuth.dev/writings/making_gnome_shell_extensions/</guid><description>I like the GNOME Shell and I&amp;rsquo;ve liked it since it was in the &amp;ldquo;testing&amp;rdquo;-repo of ArchLinux. It&amp;rsquo;s a fast and aesthetic desktop environment. But it&amp;rsquo;s a long way from offering everything you&amp;rsquo;d like to have. Luckily, it can be extended.
The following advices, instructions or sources where compiled when GNOME Shell 3.6.2 was the latest version. While specific information here might be outdated, the general idea still holds value today.</description></item><item><title>Audio Visual Environment</title><link>https://lknuth.dev/writings/audio_visual_environment/</link><pubDate>Tue, 06 Nov 2012 15:56:34 +0100</pubDate><guid>https://lknuth.dev/writings/audio_visual_environment/</guid><description>I&amp;rsquo;m a highly audio-visual human being. I like to listen to music anywhere I go, at any given time, largely for the sake of being entertained, but also because I can&amp;rsquo;t (and don&amp;rsquo;t want to) listen to other people talking. I live in the city and don&amp;rsquo;t own a car myself, so I&amp;rsquo;m taking the train or bus almost everywhere.
But in this article, I want to focus on &amp;ldquo;coding sounds&amp;rdquo;, the audio visual environment i create for myself to help me stay focused for long periods of time.</description></item><item><title>Working unbuffered Streams</title><link>https://lknuth.dev/writings/working_unbuffered_streams/</link><pubDate>Mon, 15 Oct 2012 15:54:32 +0100</pubDate><guid>https://lknuth.dev/writings/working_unbuffered_streams/</guid><description>When working with I/O in Java, you can normally choose from a variety of Stream and Reader or Writer classes to handle all the &amp;ldquo;dirty&amp;rdquo; work for you. But what happens under the hood? And why is this stuff so error prone?
Being the buffer When reading/writing binary data, for example from a Socket or a file, you should use a BufferedOutputStream. But what if you couldn&amp;rsquo;t?
Lets implement a simple binary copy ourselfs:</description></item><item><title>UDP Multicast on Android</title><link>https://lknuth.dev/writings/udp_multicast_on_android/</link><pubDate>Tue, 04 Sep 2012 15:51:15 +0100</pubDate><guid>https://lknuth.dev/writings/udp_multicast_on_android/</guid><description>I started working on a small inventory system, that keeps track of all the things I buy. To enter new items quickly into the system, I needed a barcode-scanner to scan new articles, transfer them to my computer and allow me to (for example) paste them into a focused input-field.
I wrote a small Android application, that uses zxing to scan the barcodes and a simple multicasted UDP network connection to broadcast the contents of the code to all listening network devices.</description></item><item><title>Android targeting system</title><link>https://lknuth.dev/writings/android_targeting_system/</link><pubDate>Thu, 02 Aug 2012 15:48:26 +0100</pubDate><guid>https://lknuth.dev/writings/android_targeting_system/</guid><description>I recently started supporting API Level 9 in my current project, which brought a problem with the ActionBar along. I had used it extensively in development (which was targeting post-Honeycomb devices), but it&amp;rsquo;s only available on API Level 11 and later.
Long story short, I started using ActionBarSherlock to get the ActionBar working on all devices and discovered an interesting fact about the Android building system and it&amp;rsquo;s targeting mechanism.</description></item><item><title>Saying more than nothing</title><link>https://lknuth.dev/writings/saying_more_than_nothing/</link><pubDate>Mon, 23 Jul 2012 22:00:00 +0100</pubDate><guid>https://lknuth.dev/writings/saying_more_than_nothing/</guid><description>As I was reading around on StackOverflow, digging through other peoples source code, I spotted multiple methods returning null in a variety of circumstances. I also found rather imaginative ways to handle null-values.
Although there is nothing wrong with null, the concept of null-pointers seems to be somewhat misunderstood. Let&amp;rsquo;s change that.
What are null-pointers? Wikipedia has the following to say:
A null pointer has a value reserved for indicating that the pointer does not refer to a valid object.</description></item><item><title>Rules of Immutability</title><link>https://lknuth.dev/writings/rules_of_immutability/</link><pubDate>Tue, 17 Jul 2012 22:00:00 +0100</pubDate><guid>https://lknuth.dev/writings/rules_of_immutability/</guid><description>In a perfect world, every value container (an object that only holds multiple fields of data and defines methods for access) is immutable. Immutability should always be a design-goal, especially, when creating a library or API.
In this article, I&amp;rsquo;m going to explain what immutable objects are, why they are cool and what stumbling blocks you should watch out for.
Although immutability, as a design-pattern, has no origin in any particular language, the following examples (and most of the writing) focus on the situation in the Java programming language and might not hold for other languages.</description></item><item><title>Catching Practice</title><link>https://lknuth.dev/writings/catching_practice/</link><pubDate>Fri, 06 Jul 2012 20:40:00 +0100</pubDate><guid>https://lknuth.dev/writings/catching_practice/</guid><description>I recently answered a question on StackOverflow, asking if catching an Error would be reasonable in a particular case. The original question and my answer can be found here, however I felt that my answer could be extended with a more general discussion of the implications and additional examples.
Clarification: Throwable, Error, Exception In Java, errors and exceptions (which are the main types) are thrown using the throw-keyword. Every class which extends the basic java.</description></item></channel></rss>