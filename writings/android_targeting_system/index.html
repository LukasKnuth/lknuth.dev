<!doctype html><html lang=en-us><head><link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/JetBrainsMono/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-Bold.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-BoldItalic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Android targeting system | Lukas Knuth // Developer</title><link rel=canonical href=https://lknuth.dev/writings/android_targeting_system/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Android targeting system"><meta property="og:description" content="About the Android targeting system, how it works and it's stumbling blocks."><meta property="og:type" content="article"><meta property="og:url" content="https://lknuth.dev/writings/android_targeting_system/"><meta property="article:section" content="writings"><meta property="article:published_time" content="2012-08-02T15:48:26+01:00"><meta property="article:modified_time" content="2012-08-02T15:48:26+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android targeting system"><meta name=twitter:description content="About the Android targeting system, how it works and it's stumbling blocks."><link rel=stylesheet href=https://lknuth.dev/css/styles.b80ba81354db091030af4b414bd9c1e0d6f77eb68cfa9470c580bd78bb96e7ae8b9ab256585ee48b3450eb59ff26dea067f26ae15be318c24227a3ea1145bf99.css integrity="sha512-uAuoE1TbCRAwr0tBS9nB4Nb3fraM+pRwxYC9eLuW566LmrJWWF7kizRQ61n/Jt6gZ/Jq4VvjGMJCJ6PqEUW/mQ=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://lknuth.dev/images/favicon.ico></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><header id=header><a href=https://lknuth.dev/><div id=logo style=background-image:url(https://lknuth.dev/images/logo.png)></div><div id=title><h1>Lukas Knuth // Developer</h1></div></a><div id=nav><ul><li class=icon><a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a></li><li><a href=/writings>Writings</a></li><li><a href=/about>About</a></li><li><a href=/cv>CV</a></li><li><a href=/imprint>Imprint</a></li></ul></div></header><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">Android targeting system</h1><div class=meta><div class=postdate><time datetime="2012-08-02 15:48:26 +0100 +0100" itemprop=datePublished>2012-08-02</time></div></div></header><div class=content itemprop=articleBody><p>I recently started supporting API Level 9 in my current project, which brought a problem with the ActionBar along. I had used it extensively in development (which was targeting post-Honeycomb devices), but it&rsquo;s only available on API Level 11 and later.</p><p>Long story short, I started using <a href=http://actionbarsherlock.com/>ActionBarSherlock</a> to get the ActionBar working on all devices and discovered an interesting fact about the Android building system and it&rsquo;s targeting mechanism.</p><h2 id=targeting-in-android>Targeting in Android</h2><p>When compiling a Java application with a Java 7 compiler, you can&rsquo;t use it with a Java 6 interpreter. The interpreter will tell you, that it can&rsquo;t interpret the produced byte-code, even if you&rsquo;re not using any Java 7 language features. If you want to compile with the latest compiler but make your byte-code executable on older JVM versions, you&rsquo;ll need to tell the compiler to do so (using the <code>-target</code>-flag).</p><p>In Android, you can declare what platform-versions you support in your manifest-file, using the <code>&lt;uses-sdk></code>-element and it&rsquo;s <code>android:minSdkVersion</code> and <code>android:targetSdkVersion</code>-attributes. The difference between those &ldquo;targeting mechanisms&rdquo; is, that Android does not care against which platform version the application was compiled.</p><p>If you declare your application to be compatible with API Level 4, Android will happily install it, even if you compiled it against Android 4.1 (API Level 16).</p><h3 id=pro>Pro</h3><p>This allows your application to use new API calls on newer platform, but still fully support older Android versions. It is possible to check the Android version and decide what features to use at runtime (as described <a href=#conditional-execution>further below</a>).</p><p>This way, you can make use of newer functionality on Android devices with higher API Levels and use available fallback functionality on devices with lower API Levels.</p><h3 id=contra>Contra</h3><p>But the big problem with this system is, that you <strong>loose a huge amount of compile-time security.</strong></p><p>When declaring your <code>minSdkVersion</code>, you effectively <em>promise</em>, that your App will run on this version or higher. The thing with promises is, they&rsquo;re easy to break.</p><p>If you declare your minimum SDK version to be API Level 6 and you use methods/classes which where added in API Level 11, the compiler will not complain at <em>compile-time</em>. But your App will crash at <em>execution-time</em>.</p><p>This is, where the <a href=http://tools.android.com/tips/lint>Android Lint</a> tool comes in handy.</p><h2 id=android-lint>Android Lint</h2><p>The tool website gives the following summary about it&rsquo;s functionality:</p><blockquote><p>Android Lint is a new tool introduced in ADT 16 (and Tools 16) which <strong>scans Android project sources for <em>potential</em> bugs
(which can <em>not</em> be found at compile-time)</strong>. It is available both as a command line tool, as well as integrated with
Eclipse, and IntelliJ. [&mldr;]</p></blockquote><p>As mentioned above, when building against a newer version of the platform, there is no way for the compiler to know on what versions the application needs to run. This is something the Linter can check for you.</p><h3 id=intellij-problems>IntelliJ problems</h3><div class=important><p>This section is heavily outdated! It's retained only for cohesion.</p></div><p>In the quote above, the IntelliJ integration is mentioned, although in it&rsquo;s current state (IntelliJ 11.1.3), it&rsquo;s not really worth mentioning.</p><p>The IntelliJ settings include just a few of the many many checks that the Linter can perform. My particular problem is, that the <code>NewApi</code>-check (which we&rsquo;ll further discuss in just a minute) is not included <em>at all</em>.</p><p>Also, when manually performing any Lint-checking on an IntelliJ project, there is a second problem.</p><h4 id=checking-intellij-projects-on-the-command-line>Checking IntelliJ projects on the command line</h4><p>When trying to use the CLI version of Lint, this happens:</p><pre><code>$ lint BikeTrack/
Scanning BikeTrack: ....................
BikeTrack: Error: No .class files were found in project &quot;BikeTrack&quot;, so none of the classfile based checks could be run. Does the project need to be built first? [LintError]
</code></pre><p>The problem here is, that the Linter searches a particular folder for the classfiles (See <a href=http://youtrack.jetbrains.com/issue/IDEA-88701>issue &ldquo;IDEA-88701&rdquo;</a>), which is <code>bin/classes</code> (the standard in Eclipse). The standard IntelliJ output folder is <code>out/production/MyProject</code>.</p><p>An easy workaround for this problem is to make a symlink from the IntelliJ output folder to the <code>bin/</code>-folder. Another option is to change the output-folder of IntelliJ under &ldquo;File -> Project Structure -> Project -> Project Compiler Output&rdquo;.</p><h3 id=checking-for-compatibility-problems>Checking for compatibility problems</h3><p>The Linter can check for <a href=http://tools.android.com/tips/lint-checks>many things</a>. To speed the whole thing up, you can tell it which particular checks it shall perform on your project. For the sake of this article, the &ldquo;NewApi&rdquo; check is of the biggest interest:</p><blockquote><p>Summary: <strong>Finds API accesses to APIs that are not supported in all targeted API versions</strong></p><p>[&mldr;]</p><p>This check scans through all the Android API calls in the application and <strong>warns about any calls that are not
available on <em>all</em> versions targeted by this application (according to its minimum SDK attribute in the manifest).</strong></p></blockquote><p>To run this single check on your project, use the commandline tool:</p><pre><code>$ lint --check NewApi BikeTrack/
Scanning BikeTrack: .......................................................................
No issues found.
</code></pre><p>This time, the Linter did not find anything, but if it finds something, it gives you plenty of information:</p><pre><code>$ lint --check NewApi BikeTrack/
Scanning BikeTrack: .......................................................................
src/org/knuth/biketrack/Main.java:246: Error: Call requires API level 11 (current min is 9): android.widget.ArrayAdapter#addAll [NewApi]
            tour_adapter.addAll(tours);
                         ^
1 errors, 0 warnings
</code></pre><p>You can see the source file, the line, the called method and the reason why it is not supported (and when it was introduced) in the given error.</p><p>You&rsquo;ll want to run this check before deploying your application or after every major change. When using a CI, this should always be part of your build process.</p><h2 id=using-features-of-newer-apis>Using features of newer APIs</h2><p>So, if you <em>unintentionally</em> used an API call which is not supported in every targeted platform, you&rsquo;ll receive an error from the Linter. But what if you want to <em>intentionally</em> use newer APIs when they&rsquo;re available on the device that is running the application?</p><h3 id=conditional-execution>Conditional execution</h3><p>Consider the following situation:</p><p>There are two ways to implement a feature: The first is new and shiny but requires an API Level higher then the <code>minSdkVersion</code>. The other is old and&mldr; well, not so shiny. Now, on a platform which has the needed API Level, you want to use the new and shiny way, while on older devices, you want to fall back on the &ldquo;not-so-shiny&rdquo; variation. But how do you check if the needed APIs are available at runtime?</p><p>For that purpose, there is the <code>android.os.Build.VERSION</code>-class and it&rsquo;s <a href=http://developer.android.com/reference/android/os/Build.VERSION.html#SDK_INT><code>SDK_INT</code>-field</a>. To check if a device is running (for example) Honeycomb or later, you can use this code:</p><div class=highlight><pre tabindex=0 style=color:#fe640b;background-color:#eff1f5;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8839ef>if</span> <span style=color:#04a5e5>(</span><span style=color:#7287fd>android</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>os</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>Build</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>VERSION</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>SDK_INT</span> <span style=color:#04a5e5>&gt;=</span> <span style=color:#7287fd>android</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>os</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>Build</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>VERSION_CODES</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>HONEYCOMB</span><span style=color:#04a5e5>)</span> <span style=color:#04a5e5>{</span>
</span></span><span style=display:flex><span>    <span style=color:#acb0be;font-style:italic>// call something for API Level 11+
</span></span></span><span style=display:flex><span><span style=color:#acb0be;font-style:italic></span><span style=color:#04a5e5>}</span> <span style=color:#8839ef>else</span> <span style=color:#04a5e5>{</span>
</span></span><span style=display:flex><span>    <span style=color:#acb0be;font-style:italic>// use something available before
</span></span></span><span style=display:flex><span><span style=color:#acb0be;font-style:italic></span><span style=color:#04a5e5>}</span>
</span></span></code></pre></div><p>The above code and the topic itself is further discussed in this <a href=http://stackoverflow.com/q/9959990/717341>SO question</a>.</p><h3 id=declaring-intentional-usage-of-new-apis>Declaring intentional usage of new APIs</h3><p>So, now you can check if an API is available and if so, use it. However, the Linter does not understand this check and will complain. To fix this, we&rsquo;ll need to ensure the Linter that we understand the possible error scenario but have taken the necessary precautions:</p><blockquote><p>If your code is <em>deliberately</em> accessing newer APIs, and <strong>you have ensured (e.g. with conditional execution) that this
code will only ever be called on a supported platform, then you can annotate your class or method with the</strong> <code>@TargetApi</code>
<strong>annotation</strong> specifying the local minimum SDK to apply, such as <code>@TargetApi(11)</code>, such that this check considers 11
rather than your manifest file&rsquo;s minimum SDK as the required API level.</p></blockquote><p>So now, you&rsquo;ll want to move all your post-Honeycomb code into a method and annotate it:</p><div class=highlight><pre tabindex=0 style=color:#fe640b;background-color:#eff1f5;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8839ef>if</span> <span style=color:#04a5e5>(</span><span style=color:#7287fd>android</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>os</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>Build</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>VERSION</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>SDK_INT</span> <span style=color:#04a5e5>&gt;=</span> <span style=color:#7287fd>android</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>os</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>Build</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>VERSION_CODES</span><span style=color:#04a5e5>.</span><span style=color:#df8e1d>HONEYCOMB</span><span style=color:#04a5e5>)</span> <span style=color:#04a5e5>{</span>
</span></span><span style=display:flex><span>    <span style=color:#7287fd>doHoneycombStuff</span><span style=color:#04a5e5>();</span>
</span></span><span style=display:flex><span><span style=color:#04a5e5>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#acb0be;font-style:italic>// ... Further down
</span></span></span><span style=display:flex><span><span style=color:#acb0be;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#ea76cb>@TargetApi</span><span style=color:#04a5e5>(</span>11<span style=color:#04a5e5>)</span>
</span></span><span style=display:flex><span><span style=color:#8839ef>private</span> <span style=color:#df8e1d>void</span> <span style=color:#04a5e5>doHoneycombStuff</span><span style=color:#04a5e5>(){</span>
</span></span><span style=display:flex><span>    <span style=color:#acb0be;font-style:italic>// Use API Level 11 functionality here...
</span></span></span><span style=display:flex><span><span style=color:#acb0be;font-style:italic></span><span style=color:#04a5e5>}</span>
</span></span></code></pre></div><p>After that, the Linter won&rsquo;t complain about your code in the <code>doHoneycombStuff()</code>-method and the running Android device will execute the code, depending on it&rsquo;s current platform.</p><p>An example on how I used this to get contextual menus to work with the native ActionBar (on post-Honeycomb) or the classic context-menu can be found in this commit: <a href=https://github.com/LukasKnuth/bike-track/commit/3b60c31d85c2f9f45dbd70be30ada944a85dc5a8#diff-3>BikeTrack - 3b60c31d85</a></p><h2 id=conclusion>Conclusion</h2><ul><li>If you want your application to work with the newest Android platform, build against it.</li><li>Use <code>minSdkVersion</code> to declare the <em>lowest</em> API Level which is supported by your application.</li><li>As your <code>targetSdkVersion</code>, use the API Level against which you compiled the application.</li><li>Use Lint to check for (possibly) unsupported API calls.</li><li>Use conditional execution and the <code>@TargetApi</code>-annotation to use newer APIs when available.</li></ul></div></article><footer id=footer><div class=footer-left>Copyright &copy; 2024 Lukas Knuth</div><div class=footer-right><nav><ul><li><a href=/writings>Writings</a></li><li><a href=/about>About</a></li><li><a href=/cv>CV</a></li><li><a href=/imprint>Imprint</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script></html>