<!doctype html><html lang=en-us><head><link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/JetBrainsMono/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-Bold.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-BoldItalic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-Italic.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/iAWriterQuattro/iAWriterQuattroS-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Working unbuffered Streams | Lukas Knuth // Developer</title><link rel=canonical href=https://lknuth.dev/writings/working_unbuffered_streams/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Working unbuffered Streams"><meta property="og:description" content="How to handle unbuffered streams in Java."><meta property="og:type" content="article"><meta property="og:url" content="https://lknuth.dev/writings/working_unbuffered_streams/"><meta property="article:section" content="writings"><meta property="article:published_time" content="2012-10-15T15:54:32+01:00"><meta property="article:modified_time" content="2012-10-15T15:54:32+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Working unbuffered Streams"><meta name=twitter:description content="How to handle unbuffered streams in Java."><link rel=stylesheet href=https://lknuth.dev/css/styles.0928263258ff48c63941ab9229aa210f361bc2867bf796849213c3220a0bd80f289f2e9ab7e3c190bf9912da983ec5fc0ad96975a429cbad0a8a07d379a4ace9.css integrity="sha512-CSgmMlj/SMY5QauSKaohDzYbwoZ795aEkhPDIgoL2A8ony6at+PBkL+ZEtqYPsX8CtlpdaQpy60KigfTeaSs6Q=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://lknuth.dev/images/favicon.ico></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><header id=header><a href=https://lknuth.dev/><div id=logo style=background-image:url(https://lknuth.dev/images/logo.png)></div><div id=title><h1>Lukas Knuth // Developer</h1></div></a><div id=nav><ul><li class=icon><a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a></li><li><a href=/writings>Writings</a></li><li><a href=/about>About</a></li><li><a href=/cv>CV</a></li><li><a href=/imprint>Imprint</a></li></ul></div></header><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">Working unbuffered Streams</h1><div class=meta><div class=postdate><time datetime="2012-10-15 15:54:32 +0100 +0100" itemprop=datePublished>2012-10-15</time></div></div></header><div class=content itemprop=articleBody><p>When working with I/O in Java, you can normally choose from a variety of <code>Stream</code> and <code>Reader</code> or <code>Writer</code> classes to handle all the &ldquo;dirty&rdquo; work for you. But what happens under the hood? And why is this stuff so error prone?</p><h2 id=being-the-buffer>Being the buffer</h2><p>When reading/writing binary data, for example from a <code>Socket</code> or a file, you should use a <a href=https://docs.oracle.com/javase/7/docs/api/java/io/BufferedOutputStream.html><code>BufferedOutputStream</code></a>. But what if you couldn&rsquo;t?</p><p>Lets implement a simple binary copy ourselfs:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#928374;font-style:italic>// This code is intended to be incorrect. DON&#39;T COPY THIS!
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#fabd2f>byte</span> buffer<span style=color:#fe8019>[]</span> <span style=color:#fe8019>=</span> <span style=color:#fe8019>new</span> <span style=color:#fabd2f>byte</span><span style=color:#fe8019>[</span><span style=color:#d3869b>1024</span><span style=color:#fe8019>];</span>
</span></span><span style=display:flex><span><span style=color:#fe8019>while</span> <span style=color:#fe8019>(</span>input<span style=color:#fe8019>.</span><span style=color:#b8bb26;font-weight:700>read</span><span style=color:#fe8019>(</span>buffer<span style=color:#fe8019>,</span> <span style=color:#d3869b>0</span><span style=color:#fe8019>,</span> buffer<span style=color:#fe8019>.</span><span style=color:#b8bb26;font-weight:700>length</span><span style=color:#fe8019>)</span> <span style=color:#fe8019>!=</span> <span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span style=color:#fe8019>)</span> <span style=color:#fe8019>{</span>
</span></span><span style=display:flex><span>    output<span style=color:#fe8019>.</span><span style=color:#b8bb26;font-weight:700>write</span><span style=color:#fe8019>(</span>buffer<span style=color:#fe8019>,</span> <span style=color:#d3869b>0</span><span style=color:#fe8019>,</span> buffer<span style=color:#fe8019>.</span><span style=color:#b8bb26;font-weight:700>length</span><span style=color:#fe8019>);</span>
</span></span><span style=display:flex><span><span style=color:#fe8019>}</span>
</span></span></code></pre></div><p>Can you spot the problem in the snippet? It&rsquo;s subtle. What makes it worse is that (under the correct conditions) the result <em>can</em> be perfectly correct. Never the less, this code has a bug!</p><h3 id=the-full-buffer-lie>The &ldquo;full buffer&rdquo; lie</h3><p>The problem with the code above is on line 4, the one that reads <code>output.write(buffer, 0, buffer.length)</code>. The code assumes that the buffer is always completely filled, which is not necessarily the case! The <a href=http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html#read%28byte%5B%5D,%20int,%20int%29>documentation for <code>InputStream.read(byte[], int, int)</code> states</a>:</p><blockquote><p><strong>Reads <u>up to</u> <code>len</code> bytes of data from the input stream</strong> into an array of bytes. <strong>An attempt is made to
read as many as <code>len</code> bytes, but a smaller number may be read.</strong> The number of bytes actually read is returned
as an integer. [&mldr;]</p></blockquote><p>So, the buffer is not guaranteed to be full. This becomes a problem when we use the <code>OutputStream.write(byte[], int, int)</code>-method to write the read bytes to the output stream. It&rsquo;s <a href=http://docs.oracle.com/javase/6/docs/api/java/io/OutputStream.html#write%28byte%5B%5D,%20int,%20int%29>documentation reads</a>:</p><blockquote><p><strong>Writes [exactly] <code>len</code> bytes</strong> from the specified byte array starting at offset <code>off</code> to this output stream. [&mldr;]</p></blockquote><p>Here, it&rsquo;s the other way around. When we call the method with a <code>len</code>-parameter of our byte-array size (which is and will always be 1024 in this example), the method will write exactly 1024 bytes.</p><p>Now, if the <code>read()</code>-method only read 300 bytes into the buffer and we tell the <code>write()</code>-method to write exactly 1024 bytes, the remaining 724 bytes will be filled up with null-bytes. Even worse, if we previously read 700 bytes of data into the buffer and the next call to <code>read()</code> only overwrote the first 300 bytes, the remaining 400 bytes from the previous <code>read()</code>-call will be written out again (along with another 324 null-bytes). Either case will lead to corrupted output.</p><h3 id=doing-it-right>Doing it right</h3><p>So, how do we know how many bytes where read into the buffer? Quoting again from the <a href=http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html#read%28byte%5B%5D,%20int,%20int%29><code>InputStream.read(byte[], int, int)</code>-documentation</a>:</p><blockquote><p>[&mldr;] a smaller number may be read. <strong>The number of bytes actually read is returned as an integer.</strong></p></blockquote><p>In the above example, we already checked the return-value to see if we where at the end of the stream. Now, we&rsquo;ll store it and use it as the <code>len</code>-parameter for the <code>write()</code>-method:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#fabd2f>byte</span> buffer<span style=color:#fe8019>[]</span> <span style=color:#fe8019>=</span> <span style=color:#fe8019>new</span> <span style=color:#fabd2f>byte</span><span style=color:#fe8019>[</span><span style=color:#d3869b>1024</span><span style=color:#fe8019>];</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>int</span> read_count <span style=color:#fe8019>=</span> <span style=color:#d3869b>0</span><span style=color:#fe8019>;</span>
</span></span><span style=display:flex><span><span style=color:#fe8019>while</span> <span style=color:#fe8019>((</span>read_count <span style=color:#fe8019>=</span> input<span style=color:#fe8019>.</span><span style=color:#b8bb26;font-weight:700>read</span><span style=color:#fe8019>(</span>buffer<span style=color:#fe8019>,</span> <span style=color:#d3869b>0</span><span style=color:#fe8019>,</span> buffer<span style=color:#fe8019>.</span><span style=color:#b8bb26;font-weight:700>length</span><span style=color:#fe8019>))</span> <span style=color:#fe8019>!=</span> <span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span style=color:#fe8019>)</span> <span style=color:#fe8019>{</span>
</span></span><span style=display:flex><span>    output<span style=color:#fe8019>.</span><span style=color:#b8bb26;font-weight:700>write</span><span style=color:#fe8019>(</span>buffer<span style=color:#fe8019>,</span> <span style=color:#d3869b>0</span><span style=color:#fe8019>,</span> read_count<span style=color:#fe8019>);</span> <span style=color:#928374;font-style:italic>// Now writes the correct amount of bytes
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#fe8019>}</span>
</span></span></code></pre></div><p>This will write the exact amount of bytes read from the input-stream, into the output-stream.</p><h2 id=conclusion>Conclusion</h2><ul><li>Keep track of the amount of bytes read from your input-stream.</li><li>Check to write the correct amount of bytes to your output-stream.</li><li>Use the <a href=https://docs.oracle.com/javase/7/docs/api/java/io/BufferedOutputStream.html><code>BufferedOutputStream</code></a> for binary data.</li><li>Use existing <a href=http://docs.oracle.com/javase/6/docs/api/java/io/Reader.html>Reader</a>/<a href=http://docs.oracle.com/javase/6/docs/api/java/io/Writer.html>Writer</a> implementations when handling String data.</li></ul></div></article><footer id=footer><div class=footer-left>Copyright &copy; 2023 Lukas Knuth</div><div class=footer-right><nav><ul><li><a href=/writings>Writings</a></li><li><a href=/about>About</a></li><li><a href=/cv>CV</a></li><li><a href=/imprint>Imprint</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script></html>