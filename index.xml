<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lukas Knuth // Developer</title><link>https://lknuth.dev/</link><description>Recent content on Lukas Knuth // Developer</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Lukas Knuth</copyright><lastBuildDate>Thu, 28 Dec 2023 14:00:00 +0200</lastBuildDate><atom:link href="https://lknuth.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Design a Technical Interview</title><link>https://lknuth.dev/writings/design_technical_interview/</link><pubDate>Thu, 28 Dec 2023 14:00:00 +0200</pubDate><guid>https://lknuth.dev/writings/design_technical_interview/</guid><description>Last year, the company I work for was looking to hire a Backend Engineer. We wanted somebody who was a senior or on their way to becoming one.
The Backend Squad was tasked with designing an interview to help decide who to hire based on technical merit. Above all, we wanted our interview to favor candidates that are good fits. Now, after working with our new hire for about 11 months, we know that we succeeded.</description></item><item><title>Work in an efficient team</title><link>https://lknuth.dev/writings/efficient_team/</link><pubDate>Fri, 02 Jun 2023 15:10:00 +0200</pubDate><guid>https://lknuth.dev/writings/efficient_team/</guid><description>Some years ago I worked in a team of software developers which I still consider the most productive team I have ever been a part of. We built a large system for our internal users with a dozen product team members and had a turnaround time from idea to implementation of about three weeks. This is how we did it.
Day to day The work that needed doing was split into two buckets: the eternal pull-queue of tasks like maintenance or smaller adjustments to existing services, and the frequent but short projects we did to build new services or make larger changes to existing ones.</description></item><item><title>Delightfully Boring</title><link>https://lknuth.dev/writings/delightfully_boring/</link><pubDate>Mon, 15 May 2023 13:30:00 +0200</pubDate><guid>https://lknuth.dev/writings/delightfully_boring/</guid><description>This article was originally published on tech.7mind.de
When I joined 7Mind a year ago, I was hired partially to help migrate the existing system away from micro-services towards a new monolithic Elixir application.
This decision was made before I had joined, but having worked in a company that went very all-in on micro-services before, I welcomed it. But first, some background.
As with many older startups, their initial system was not designed to handle whatever the day-to-day is now, many years later.</description></item><item><title>About</title><link>https://lknuth.dev/about/</link><pubDate>Wed, 19 Oct 2022 01:21:00 +0200</pubDate><guid>https://lknuth.dev/about/</guid><description>Hi, I&amp;rsquo;m Lukas. I make computers do useful things for a living.
I found my passion for computers pretty early in my live and have been on a straight path towards my career ever since, getting vocational training and a bachelors degree in Computer Science.
Since I started my professional career, I have been a Mobile Developer on Android, a Web Developer using multiple frontend frameworks, a Full-Stack Developer focused on NodeJS, Ruby and Elixir and most recently a Senior Backend Developer working mostly with Elixir.</description></item><item><title>Impressum</title><link>https://lknuth.dev/imprint-de/</link><pubDate>Wed, 19 Oct 2022 01:21:00 +0200</pubDate><guid>https://lknuth.dev/imprint-de/</guid><description>Impressum auf Englisch / Imprint in English
Angaben gemäß § 5 TMG Lukas Knuth
Tannenbergstraße 7
51465 Bergisch Gladbach
Germany
Kontakt E-Mail: me @ die domain dieses blogs
Verantwortlich für den Inhalt nach § 55 Abs. 2 RStV Lukas Knuth
Tannenbergstraße 7
51465 Bergisch Gladbach
Germany
Haftung für Inhalte Als Diensteanbieter sind wir gemäß § 7 Abs.1 TMG für eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach §§ 8 bis 10 TMG sind wir als Diensteanbieter jedoch nicht verpflichtet, übermittelte oder gespeicherte fremde Informationen zu überwachen oder nach Umständen zu forschen, die auf eine rechtswidrige Tätigkeit hinweisen.</description></item><item><title>Imprint</title><link>https://lknuth.dev/imprint/</link><pubDate>Wed, 19 Oct 2022 01:21:00 +0200</pubDate><guid>https://lknuth.dev/imprint/</guid><description>Impressum auf Deutsch / Imprint in German
Information in accordance with § 5 TMG Lukas Knuth
Tannenbergstraße 7
51465 Bergisch Gladbach
Germany
Contact Information E-Mail: me @ the domain of this blog
Responsible for content in accordance with § 55 parag. 2 RStV Lukas Knuth
Tannenbergstraße 7
51465 Bergisch Gladbach
Germany
Accountability for content The contents of our pages have been created with the utmost care. However, we cannot guarantee the contents’ accuracy, completeness or topicality.</description></item><item><title>Dangerously Typed</title><link>https://lknuth.dev/writings/dangerously_typed/</link><pubDate>Sat, 07 Jan 2017 16:05:00 +0100</pubDate><guid>https://lknuth.dev/writings/dangerously_typed/</guid><description>At work, I&amp;rsquo;m currently building an new Node.js Application. I opted to use Node, because the application is highly parallel and while I could have build it in Java, Node already does all the hard things that come with building multi-threaded Applications.
For my language of choice, I looked to TypeScript, because it adds some compile-time type-safety to JavaScript. For the most part, TypeScript has been helping me to write clean code that I can trust when the compiler gives it&amp;rsquo;s &amp;ldquo;all clear&amp;rdquo;.</description></item><item><title>TTS and Usability</title><link>https://lknuth.dev/writings/tts_and_usability/</link><pubDate>Fri, 13 Jun 2014 16:02:43 +0100</pubDate><guid>https://lknuth.dev/writings/tts_and_usability/</guid><description>There are limited yet very legit use-cases for Text to Speech engines in your application.
An example for such a case is an application that has focus and is doing its thing, but doesn&amp;rsquo;t require physical interaction with the device. These applications might still want to update the user regularly, without touching or looking at the device. An example of such an application is a Navigation-app or my own BikeTrack.</description></item><item><title>Generating Qrcodes With Zxing</title><link>https://lknuth.dev/writings/generating_qrcodes_with_zxing/</link><pubDate>Sun, 25 Aug 2013 16:00:11 +0100</pubDate><guid>https://lknuth.dev/writings/generating_qrcodes_with_zxing/</guid><description>When it comes to reading QR-codes, most Android applications use the ZXing library. It&amp;rsquo;s capabilities and ease of use when reading QR-Codes is already known, but ZXing can also generate QR-Codes.
Sadly, a lack of documentation makes it pretty hard to dive into this topic, so this article aims to provide a simple starting point.
Integration choices There are two ways to integrate ZXing in your application: by using Intents or as a library.</description></item><item><title>Making GNOME Shell Extensions</title><link>https://lknuth.dev/writings/making_gnome_shell_extensions/</link><pubDate>Sat, 09 Feb 2013 15:57:38 +0100</pubDate><guid>https://lknuth.dev/writings/making_gnome_shell_extensions/</guid><description>I like the GNOME Shell and I&amp;rsquo;ve liked it since it was in the &amp;ldquo;testing&amp;rdquo;-repo of ArchLinux. It&amp;rsquo;s a fast and aesthetic desktop environment. But it&amp;rsquo;s a long way from offering everything you&amp;rsquo;d like to have. Luckily, it can be extended.
The following advices, instructions or sources where compiled when GNOME Shell 3.6.2 was the latest version. While specific information here might be outdated, the general idea still holds value today.</description></item><item><title>Audio Visual Environment</title><link>https://lknuth.dev/writings/audio_visual_environment/</link><pubDate>Tue, 06 Nov 2012 15:56:34 +0100</pubDate><guid>https://lknuth.dev/writings/audio_visual_environment/</guid><description>I&amp;rsquo;m a highly audio-visual human being. I like to listen to music anywhere I go, at any given time, largely for the sake of being entertained, but also because I can&amp;rsquo;t (and don&amp;rsquo;t want to) listen to other people talking. I live in the city and don&amp;rsquo;t own a car myself, so I&amp;rsquo;m taking the train or bus almost everywhere.
But in this article, I want to focus on &amp;ldquo;coding sounds&amp;rdquo;, the audio visual environment i create for myself to help me stay focused for long periods of time.</description></item><item><title>Working unbuffered Streams</title><link>https://lknuth.dev/writings/working_unbuffered_streams/</link><pubDate>Mon, 15 Oct 2012 15:54:32 +0100</pubDate><guid>https://lknuth.dev/writings/working_unbuffered_streams/</guid><description>When working with I/O in Java, you can normally choose from a variety of Stream and Reader or Writer classes to handle all the &amp;ldquo;dirty&amp;rdquo; work for you. But what happens under the hood? And why is this stuff so error prone?
Being the buffer When reading/writing binary data, for example from a Socket or a file, you should use a BufferedOutputStream. But what if you couldn&amp;rsquo;t?
Lets implement a simple binary copy ourselfs:</description></item><item><title>UDP Multicast on Android</title><link>https://lknuth.dev/writings/udp_multicast_on_android/</link><pubDate>Tue, 04 Sep 2012 15:51:15 +0100</pubDate><guid>https://lknuth.dev/writings/udp_multicast_on_android/</guid><description>I started working on a small inventory system, that keeps track of all the things I buy. To enter new items quickly into the system, I needed a barcode-scanner to scan new articles, transfer them to my computer and allow me to (for example) paste them into a focused input-field.
I wrote a small Android application, that uses zxing to scan the barcodes and a simple multicasted UDP network connection to broadcast the contents of the code to all listening network devices.</description></item><item><title>Android targeting system</title><link>https://lknuth.dev/writings/android_targeting_system/</link><pubDate>Thu, 02 Aug 2012 15:48:26 +0100</pubDate><guid>https://lknuth.dev/writings/android_targeting_system/</guid><description>I recently started supporting API Level 9 in my current project, which brought a problem with the ActionBar along. I had used it extensively in development (which was targeting post-Honeycomb devices), but it&amp;rsquo;s only available on API Level 11 and later.
Long story short, I started using ActionBarSherlock to get the ActionBar working on all devices and discovered an interesting fact about the Android building system and it&amp;rsquo;s targeting mechanism.</description></item><item><title>Saying more than nothing</title><link>https://lknuth.dev/writings/saying_more_than_nothing/</link><pubDate>Mon, 23 Jul 2012 22:00:00 +0100</pubDate><guid>https://lknuth.dev/writings/saying_more_than_nothing/</guid><description>As I was reading around on StackOverflow, digging through other peoples source code, I spotted multiple methods returning null in a variety of circumstances. I also found rather imaginative ways to handle null-values.
Although there is nothing wrong with null, the concept of null-pointers seems to be somewhat misunderstood. Let&amp;rsquo;s change that.
What are null-pointers? Wikipedia has the following to say:
A null pointer has a value reserved for indicating that the pointer does not refer to a valid object.</description></item><item><title>Rules of Immutability</title><link>https://lknuth.dev/writings/rules_of_immutability/</link><pubDate>Tue, 17 Jul 2012 22:00:00 +0100</pubDate><guid>https://lknuth.dev/writings/rules_of_immutability/</guid><description>In a perfect world, every value container (an object that only holds multiple fields of data and defines methods for access) is immutable. Immutability should always be a design-goal, especially, when creating a library or API.
In this article, I&amp;rsquo;m going to explain what immutable objects are, why they are cool and what stumbling blocks you should watch out for.
Although immutability, as a design-pattern, has no origin in any particular language, the following examples (and most of the writing) focus on the situation in the Java programming language and might not hold for other languages.</description></item><item><title>Catching Practice</title><link>https://lknuth.dev/writings/catching_practice/</link><pubDate>Fri, 06 Jul 2012 20:40:00 +0100</pubDate><guid>https://lknuth.dev/writings/catching_practice/</guid><description>I recently answered a question on StackOverflow, asking if catching an Error would be reasonable in a particular case. The original question and my answer can be found here, however I felt that my answer could be extended with a more general discussion of the implications and additional examples.
Clarification: Throwable, Error, Exception In Java, errors and exceptions (which are the main types) are thrown using the throw-keyword. Every class which extends the basic java.</description></item><item><title>Curriculum Vitae</title><link>https://lknuth.dev/cv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lknuth.dev/cv/</guid><description>I am generally open to be contacted about new opportunities.</description></item></channel></rss>